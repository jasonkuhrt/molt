# @molt/command

ðŸŒ± Simple type-safe CLI command parsing..

## Installation

```
npm add @molt/command
```

## Features

- Automatic parameter parsing based on specified Zod types.
- Normalization between camel/kebab case:

  - Kebab case parameter spec normalized to camel
    ```ts
    // foobar.ts
    const args1 = Command.create({ '--do-it': z.boolean() }).parseOrThrow()
    const args2 = Command.create({ '--doIt': z.boolean() }).parseOrThrow()
    args1.doIt
    args2.doIt
    ```
  - Kebab case parameter input normalized to camel.
    ```
    $ ts-node foobar.ts --do-it
    $ ts-node foobar.ts --doIt
    ```

- Short and/or long flag names plus as many short/long aliases as you wish.
  ```ts
  Command.create({ '-f --force --forcefully': z.boolean() }).parseOrThrow()
  ```
- Leverage Zod `.default(...)` method for setting default values.

  ```ts
  // foobar.ts
  const args = Command.create({ '--path': z.string().default('./a/b/c') }).parseOrThrow()
  // Given: $ ts-node foobar.ts
  args.path === './a/b/c/'
  // Given: $ ts-node foobar.ts --path /over/ride
  args.path === '/over/ride'
  ```

- Leverage Zod `.describe(...)` for automatic docs.
- In the future: automatic help generation.

## Zod Types

Zod types affect flag parsing in the following ways.

### Boolean

- Flag does not accept any arguments.
- Flag of name e.g. `foo` can be passed as `--no-foo` or `--foo`. `--foo` leads to `true` while `--no-foo` leads to `false`.

Examples:

```ts
// foobar.ts
const args = Command.create({ '-f --force --forcefully': z.boolean() }).parseOrThrow()
// Given: $ ts-node foobar.ts --no-f
// Given: $ ts-node foobar.ts --noF
// Given: $ ts-node foobar.ts --no-force
// Given: $ ts-node foobar.ts --noForce
// Given: $ ts-node foobar.ts --no-forcefully
// Given: $ ts-node foobar.ts --noForcefully
args.force === false
// Given: $ ts-node foobar.ts -f
// Given: $ ts-node foobar.ts --force
// Given: $ ts-node foobar.ts --forcefully
args.force === true
```

### Number

- Flag expects an argument.
- Argument is cast via the `Number()` function.

### Enum

- Flag expects an argument.

## Example

```ts
// convert.ts
import { Command } from '@molt/command'
import { z } from 'zod'

const args = Command.parseOrThrow({
  '--file-path': z.string().describe(`Path to the file to convert.`),
  '--to': z.enum(['json', ' yaml', 'toml']).describe(`Format to convert to.`),
  '--from': z
    .enum(['json', 'yaml', 'toml'])
    .optional()
    .describe(`Format to convert from. By default inferred from the file extension.`),
  '--verbose -v': z.boolean().default(false).describe(`Log detailed progress as conversion executes.`),
  '--move -m': z.boolean().default(false).describe(`Delete the original file after it has been converted.`),
})

// Normalized, validated, statically typed, and ready to go!
args.filePath
args.to
args.from
args.verbose
args.move
```

```
ts-node convert --file ./music.yaml --to json
```

On the roadmap, autogenerated help:

```
ts-node convert --help

PARAMETERS

  ---REQUIRED--------------------------------------------------------------

  to              Format to convert to.             enum:  json, yaml, toml

  file-path       Path to the file to convert.      string

  ---OPTIONAL--------------------------------------------------------------

  from            Format to convert from. By        enum:  json, yaml, toml   <dynamic>
                  default inferred from the file
                  extension.

  verbose         Log detailed progress.            boolean                   false
  v

  move            Delete the original file after    boolean                   false
  v               it has been converted.

  ---SPECIAL--------------------------------------------------------------

  help           Output this manual to stdout.
  h

SUB-COMMANDS

  help           Output this manual to stdout.

USAGE NOTES

- All parameters can be passed in "camelCase" or "kebab-case"
- All boolean parameters have a negated variant. E.g. for --verbose you can also pass --no-verbose
```
